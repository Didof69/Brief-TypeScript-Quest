
# Consignes

Tu vas devoir trouver les informations suivantes et les tester au fur et √† mesure dans ton programme pour exp√©rimenter et comprendre comment TypeScript pourra t'aider √† √©crire ton meilleur code !

## Level 1

1- Quels sont les diff√©rents types primitives de donn√©es en TypeScript ? 

Les differents types primitives sont :

- string : repr√©sente une chaine de caract√®res 
```
- const name: string = "Lydie";
```

- number : repr√©sente un nombre composer des chiffres de 0 √† 9
```
const age: number = 40;
```

- boolean : represente deux valeurs true et false
```
const status: boolean = true;
```

- void : type de retour des fonctions qui ne renvoient aucun type de valeur
```
function sayHi(): void { 
    console.log('Hi!')
} 

let speech: void = sayHi(); 
console.log(speech); //Output: undefined
```

- null : repr√©sente une variable dont la valeur n‚Äôest pas d√©finie

- undefined : d√©signe toutes les variables non initialis√©es
```
let x: number;
let y: number | undefined;
let z: number | null | undefined;
x = 1; // Ok
y = 1; // Ok
z = 1; // Ok
x = undefined; // Error
y = undefined; // Ok
z = undefined; // Ok
x = null; // Error
y = null; // Error
z = null; // Ok
x = y; // Error
x = z; // Error
y = x; // Ok
y = z; // Error
z = x; // Ok
z = y; // Ok
```

Pour connaitre le type d'un variable, on peut utiliser `typeof`:
```
let age: number = 4;
console.log(typeof age);
//attendu 'number'
```

2- Comment typer un tableau ? 

Un tableau est typ√© avant les [].
Exemple d'un tableau compos√© de strings :
```
let tab: string[];
```
Exemple d'un tableau compos√© de numbers :
```
let tab: number[];
```
Exemple d'un tableau compos√© de booleans et de numbers :
```
let tab: (boolean | number)[];
```

On peut egalement utiliser la syntaxe Array\<Type>.
```
let tab: Array<boolean>;
```

3- Quel est le type `any` ?

Le type `any` permet de cr√©er une variable qui accepte tous les types.
C'est d√©conseill√© car peut cr√©er de nombreuses erreurs.

4- Comment typer le retour d'une fonction ainsi que le type de ses param√®tres ? 

Le typage du retour d'une fonction et du/des param√®tres se fait dans la d√©claration.
```
function jeTypeMaFonction(name: string): string {
   return "Je suis une " + name";
}
function('string');
```

**üéâüéâüéâMettre √† jour le tableau Github Projectüéâüéâüéâ**

## Level 2

1- Qu'est ce qu'une classe ? 

Une classe est une structure qui d√©finit les caract√©ristiques et le comportement d'un objet.
Les donn√©es de l'objet sont encapsul√©es dans la classe.
Une classe est compos√©e d'un mot cl√© 'class', d'un nom de classe et de {} qui encapsulent les donn√©es de l'objet (caract√©ristiques).
```
class ma_classe { 
   //donn√©es de l'objet
}
```
Pour assigner un donn√©e dans un objet, on peut utiliser une propri√©t√© qui doit √™tre typ√©e.
```
class ma_classe { 
   eleve : string;
}
// ici la propri√©t√© 'eleve' a √©t√© assign√© et typ√©e 'string'
```

2- Qu'est ce qu'un constructeur de classe ? 

Un constructeur de classe est similaire √† une m√©thode. Il est ajouter √† la classe en utilisant le mot-cl√© 'contructor'. Il est construit comme une m√©thode mais il n'est pas possible de lui assigner un nom ou un type de retour.
Il permet d'initialiser les valeurs des prorpri√©t√©s d'une instance.

```
class ma_classe { 
  eleveFirstName: string; 
  eleveLastName: string; 
 
  constructor() { 
    this.eleveFirstName = "Lydie"; 
    this.eleveLastName = "Chevalier"; 
  } 
 
  getEleveFullName(): string { 
    return `${this.eleveFirstName} ${this.eleveLastName}`; 
  } 
} 
 
const eleve = new Eleve(); 
const eleveFullName = eleve.getEleveFullName(); 
 
// Log: Lydie Chevalier 
console.log(eleveFullName); 
```

3- Qu'est ce qu'une instance de classe ?

Une instance de classe est un nouvel objet.
C'est un exemplaire unique issu d'une classe.

```
let object_name = new class_name([ arguments ])
//Exemple
let voiture = new Voiture("BMW");
```
Pour faire rapide : une classe est un "moule" qui permet de cr√©er des instances.

4- Comment v√©rifier qu'une instance est d'une certaine classe ?

Gr√¢ce √† l'op√©rateur `instanceOf` il est possible de v√©rifier si un objet est d'une certaine classe. 
```
anObject instanceof AClass;

let result = anObject instanceof AClass;
```
On peut utiliser cet op√©rateur seulement avec un objet √† gauche et une classe √† droite.
Si l'objet est bien une instance de la classe alors le retour sera 'true' sinon 'false' sera renvoy√©.

5- Qu'est ce que `this` dans une classe ?

Le mot-cl√© `this` fait r√©f√©rence √† l'instance actuelle de la classe. 
```
class Voiture { 
   //Champs
   marque:string; 
 
   //constructor 
   constructor(marque:string) { 
      this.marque = marque 
   }  

   //fonction 
    marque_voiture():void { 
      console.log('Marque : '+this.engine);
   } 
}
```

6- Qu'est ce qu'une m√©thode de classe ? 

C'est une fonction attach√©e √† l'instance d'une classe.
```
class ma_classe { 
   eleveName(param1: string, param2: string, ...): string { 
    // ... 
  } 
}
// ici la m√©thode 'eleveName' est typ√©e 'string' et comporte deux parametres typ√©s 'string'
```

7- Qu'est ce que la visibilit√© des propri√©t√©s ? 

Il existe trois types de visilit√© :
- public
- protected
- private

```
class User {
  private lastname: string
  private firstname: string
}
```

On utilise ces termes avant le nom de la propri√©t√© pour rendre la propri√©t√© accessible ou non en externe.
Par d√©faut, tout membre de classe est `public`.
Les membres `protected` ne sont visibles que dans les classes, ou sous-classes, qui les a d√©clar√©s.
Pour `private`, ressemble √† `protected`, mais les membres `private` seront visibles uniquement dans la classe qui les a d√©clar√©s.


**üéâüéâüéâMettre √† jour le tableau Github Projectüéâüéâüéâ**

## Level 3

1- Comment faire pour diviser notre programme en diff√©rents fichiers ? (ex: une classe dans un fichier que j'importe dans un autre) 

Il est possible d'importer ou d'exporter une classe dans un autre fichier TS.
Pour √ßa deux mots cl√©s `export` et `import`.

Pour pouvoir importer, il est n√©cessaire d'avoir exporter le module. 

Exportation :
```
export class exportedFile {
    sayHello(user){
        return "Hello " + user+ "!";
    }
}

```
Importation :
```
import { exportedFile } from "./exportedFile";
  
let user = new exportedFile();
  
console.log(user.sayHello("Geek"));
```


2- Qu'est ce que l'h√©ritage ? 

L'h√©ritage est le fait de pouvoir cr√©er une nouvelle classe √† partir d'une classe d√©j√† existante.
La premi√®re classe est appel√©e 'classe m√®re' et la deuxi√®me 'classe fille'.La classe fille h√©rite des propri√©t√©s de la classe m√®re.

Pour utiliser l'h√©ritage, il y a le mot-cl√© `extends`. Il prend en charge l'h√©ritage simple ou √† plusieurs niveaux mais pas l'h√©ritage multipe ou hybride.

```
class Personne {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
}

class Eleve extends Personne {
    niveauEleve: number;
    
    constructor(niveauEleve: number, name:string) {
        super(name);
        this.niveauEleve = niveauEleve;
    }
    
    displayName():void {
        console.log("Nom = " + this.name +  ", Niveau = " + this.niveauEleve);
    }
}

let eleve = new Eleve(3, "Chevalier");
eleve.displayName(); // Nom = Chevalier, Niveau = 3
```

3- Comment appeler le constructeur d'une classe m√®re ?

Le mot cl√© `super` dans la classe fille permet d'appeler le constructor de la classe m√®re. /!\ Il est nessaire de pr√©ciser dans les () la totalit√© des propri√©t√©s de la classe m√®re.

4- Comment appeler une m√©thode d'une classe m√®re ? 

Pour appeler une m√©thode d'une classe m√®re depuis une classe fille, il suffit d'utiliser le nom de la classe fille '.' le nom de la m√©thode de la classe m√®re.
```
class mere {
    maFunction(); //m√©thode d√©clar√©e dans la classe m√®re
}

class fille extends m√®re {}; //r√©cup√®re l'h√©ritage de la classe m√®re

fille.maFunction(); // utilise grace au nom de la classe fille la m√©thode de la classe m√®re
```

5- Qu'est ce que le polymorphisme ? 

Le polymorphisme permet de traiter des objets de diff√©rents types d'une mani√®re identique.

**üéâüéâüéâMettre √† jour le tableau Github Projectüéâüéâüéâ**

## Boss level 

Met en pratique le fruit de tes recherches √† travers cet exercice en bin√¥me !
### Partie 1 : H√©ros

La classe `Hero` permet de cr√©er des objets poss√©dant les propri√©t√©s suivantes :

    name : string
    power : number
    life : number

‚ÄãEt les m√©thodes

    attack(opponent: Hero)
    isAlive()

‚ÄãLa m√©thode `attack` a un param√®tre `opponent` (de type `Hero`). Il faut r√©duire le nombre (`life`) de `opponent` d'autant de d√©gats (`power`) de l'attaquant.

‚Äã
*Exemple : Si Joan attaque Leon, cela sera repr√©sent√© par :*

    joan.attack(leon)

‚ÄãLa m√©thode `isAlive` devrait retourner `true` si le nombre de points de vie du h√©ros est sup√©rieur √† z√©ro et `false` sinon.

Cr√©e deux instances de `Hero` et v√©rifie que les m√©thodes `attack` et `isAlive` fonctionnent.

**Contrainte √† ajouter** : il faut maintenant faire en sorte que les propri√©t√©s `name`, `power`, `life` soient priv√©es. Tu vas devoir cr√©er des m√©thodes permettant d'acc√©der √† leur valeur et de modifier leur valeur.

### Partie 2 : Armes
‚Äã
Cr√©e une classe `Weapon` avec la propri√©t√© suivante :

    name : string

Ajoute l'attribut `weapon` (de type `Weapon`) √† la classe `Hero` sans modifier le constructeur (ainsi `weapon` n'est pas initialis√©).

Cr√©e trois classes `HeroAxe`, `HeroSword` et `HeroSpear` qui h√©ritent de `Hero`.

Ces trois classes appellent le constructeur de leur parent et initialisent `weapon` avec des instances de la classe `Weapon` dont les noms seront `axe`, `sword` ou `spear` selon le cas.

Dans les classes `HeroAxe`, `HeroSword` et `HeroSpear`, red√©finisse la m√©thode `attack` pour prendre en compte les cas suivants :

- `HeroAxe` : si le type de `opponent` est `HeroSword`, multiplier `power` par deux
- `HeroSword` : si le type de `opponent` est `HeroSpear`, multiplier `power` par deux
- `HeroSpear` : si le type de `opponent` est `HeroAxe`, multiplier `power` par deux

‚Äã
Astuce : utilise le mot-cl√© `super` pour appeler la m√©thode `attack` de la classe parente.

Cr√©e des instances des trois classes `HeroAxe`, `HeroSword` et `HeroSpear` et v√©rifie que leurs m√©thodes `attack` fonctionnent correctement.
‚Äã
### Partie 3 : Bataille

Cr√©e une boucle qui fait que deux instances de sous-classes `Hero` s'affrontent (elles attaquent en m√™me temps).

Quand au moins l'une d'entre elles est morte, afficher `{heroName} wins`. Si les deux sont morts, afficher `It's a draw`.

**üéâüéâüéâMettre √† jour le tableau Github Projectüéâüéâüéâ**

---

***Bonus 1 : Les d√©g√¢ts de l'arme***

*Ajoute une propri√©t√© `damage` √† la classe `Weapon` et fait en sorte qu'elle soit initialis√©e par le constructeur.*

*Modifie la m√©thode `attack` de `Hero` afin que les d√©g√¢ts soient calcul√©s de la fa√ßon suivante : la puissance du h√©ro `power` + les d√©g√¢ts de l'arme `power`*

***Bonus 2 : Interface graphique***

*R√©alise une interface graphique pour l'application (par exemple, avec un choix de h√©ros et d'armes, et un visuel sur les d√©g√¢ts inflig√©s)*

